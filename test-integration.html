<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>çµ±åˆãƒ†ã‚¹ãƒˆ - ã²ã‚‰ãŒãªæ‰‹æ›¸ãç·´ç¿’ã‚¢ãƒ—ãƒª</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background: #f5f5f5;
        }
        .test-container {
            max-width: 800px;
            margin: 0 auto;
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        .test-section {
            margin-bottom: 30px;
            padding: 15px;
            border: 1px solid #ddd;
            border-radius: 5px;
        }
        .test-section h3 {
            color: #333;
            margin-top: 0;
        }
        .test-result {
            padding: 10px;
            margin: 5px 0;
            border-radius: 3px;
        }
        .test-pass {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }
        .test-fail {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }
        .test-info {
            background: #d1ecf1;
            color: #0c5460;
            border: 1px solid #bee5eb;
        }
        .run-button {
            background: #007bff;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            margin: 5px;
        }
        .run-button:hover {
            background: #0056b3;
        }
        .run-button:disabled {
            background: #6c757d;
            cursor: not-allowed;
        }
        #app {
            display: none;
        }
        .progress-bar {
            width: 100%;
            height: 20px;
            background: #e9ecef;
            border-radius: 10px;
            overflow: hidden;
            margin: 10px 0;
        }
        .progress-fill {
            height: 100%;
            background: #28a745;
            width: 0%;
            transition: width 0.3s ease;
        }
    </style>
</head>
<body>
    <div class="test-container">
        <h1>ã²ã‚‰ãŒãªæ‰‹æ›¸ãç·´ç¿’ã‚¢ãƒ—ãƒª - çµ±åˆãƒ†ã‚¹ãƒˆ</h1>
        
        <div class="test-section">
            <h3>ãƒ†ã‚¹ãƒˆå®Ÿè¡Œ</h3>
            <button class="run-button" onclick="runAllTests()">å…¨ãƒ†ã‚¹ãƒˆå®Ÿè¡Œ</button>
            <button class="run-button" onclick="runBrowserTests()">ãƒ–ãƒ©ã‚¦ã‚¶å¯¾å¿œãƒ†ã‚¹ãƒˆ</button>
            <button class="run-button" onclick="runIntegrationTests()">çµ±åˆãƒ†ã‚¹ãƒˆ</button>
            <button class="run-button" onclick="runPerformanceTests()">ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãƒ†ã‚¹ãƒˆ</button>
            
            <div class="progress-bar">
                <div class="progress-fill" id="progress"></div>
            </div>
            <div id="test-status">ãƒ†ã‚¹ãƒˆå¾…æ©Ÿä¸­...</div>
        </div>

        <div class="test-section">
            <h3>ãƒ–ãƒ©ã‚¦ã‚¶å¯¾å¿œçŠ¶æ³</h3>
            <div id="browser-support"></div>
        </div>

        <div class="test-section">
            <h3>çµ±åˆãƒ†ã‚¹ãƒˆçµæœ</h3>
            <div id="integration-results"></div>
        </div>

        <div class="test-section">
            <h3>ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãƒ†ã‚¹ãƒˆçµæœ</h3>
            <div id="performance-results"></div>
        </div>

        <div class="test-section">
            <h3>ã‚¨ãƒ©ãƒ¼ãƒ­ã‚°</h3>
            <div id="error-log"></div>
        </div>
    </div>

    <!-- ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³è¦ç´ ï¼ˆãƒ†ã‚¹ãƒˆç”¨ï¼‰ -->
    <div id="app">
        <div id="main-menu" class="screen active">
            <button id="start-practice-btn">ç·´ç¿’ã‚’ã¯ã˜ã‚ã‚‹</button>
        </div>
        <div id="practice-view" class="screen">
            <span id="target-character">ã‚</span>
            <canvas id="drawing-canvas" width="400" height="400"></canvas>
            <button id="show-example-btn">æ‰‹æœ¬ã‚’è¦‹ã‚‹</button>
            <button id="clear-canvas-btn">æ¶ˆã™</button>
            <button id="submit-drawing-btn">ã§ããŸï¼</button>
        </div>
        <div id="example-view" class="screen">
            <span id="example-character">ã‚</span>
            <button id="back-to-practice-btn">ç·´ç¿’ã«æˆ»ã‚‹</button>
        </div>
        <div id="result-view" class="screen">
            <div id="score-icon">ğŸ˜Š</div>
            <div id="score-message">ã‚ˆãã§ãã¾ã—ãŸï¼</div>
            <button id="try-again-btn">ã‚‚ã†ä¸€åº¦</button>
            <button id="next-character-btn">æ¬¡ã®æ–‡å­—</button>
        </div>
    </div>

    <script type="module">
        import { App } from './js/app.js';
        import { ErrorHandler } from './js/services/ErrorHandler.js';
        import { DrawingService } from './js/services/DrawingService.js';
        import { RecognitionService } from './js/services/RecognitionService.js';
        import { ScoreService } from './js/services/ScoreService.js';

        let testResults = [];
        let currentTestIndex = 0;
        let totalTests = 0;

        // ãƒ†ã‚¹ãƒˆçµæœè¡¨ç¤ºç”¨ãƒ˜ãƒ«ãƒ‘ãƒ¼
        function addTestResult(section, name, passed, message = '', details = null) {
            const result = { section, name, passed, message, details, timestamp: new Date() };
            testResults.push(result);
            
            const sectionElement = document.getElementById(section);
            if (sectionElement) {
                const resultDiv = document.createElement('div');
                resultDiv.className = `test-result ${passed ? 'test-pass' : 'test-fail'}`;
                resultDiv.innerHTML = `
                    <strong>${passed ? 'âœ“' : 'âœ—'} ${name}</strong>
                    ${message ? `<br><small>${message}</small>` : ''}
                    ${details ? `<br><pre style="font-size: 0.8em; margin: 5px 0;">${JSON.stringify(details, null, 2)}</pre>` : ''}
                `;
                sectionElement.appendChild(resultDiv);
            }
        }

        function updateProgress(current, total) {
            const percentage = (current / total) * 100;
            document.getElementById('progress').style.width = `${percentage}%`;
            document.getElementById('test-status').textContent = `ãƒ†ã‚¹ãƒˆå®Ÿè¡Œä¸­... ${current}/${total}`;
        }

        // ãƒ–ãƒ©ã‚¦ã‚¶å¯¾å¿œãƒ†ã‚¹ãƒˆ
        async function runBrowserTests() {
            const tests = [
                {
                    name: 'Canvas APIå¯¾å¿œ',
                    test: () => {
                        const canvas = document.createElement('canvas');
                        const ctx = canvas.getContext('2d');
                        return !!ctx;
                    }
                },
                {
                    name: 'LocalStorageå¯¾å¿œ',
                    test: () => {
                        try {
                            localStorage.setItem('test', 'value');
                            const value = localStorage.getItem('test');
                            localStorage.removeItem('test');
                            return value === 'value';
                        } catch (e) {
                            return false;
                        }
                    }
                },
                {
                    name: 'ã‚¿ãƒƒãƒã‚¤ãƒ™ãƒ³ãƒˆå¯¾å¿œ',
                    test: () => {
                        return 'ontouchstart' in window || navigator.maxTouchPoints > 0;
                    }
                },
                {
                    name: 'ES6æ©Ÿèƒ½å¯¾å¿œ',
                    test: () => {
                        return typeof Symbol !== 'undefined' && typeof Promise === 'function';
                    }
                },
                {
                    name: 'Web Audio APIå¯¾å¿œ',
                    test: () => {
                        return !!(window.AudioContext || window.webkitAudioContext);
                    }
                },
                {
                    name: 'requestAnimationFrameå¯¾å¿œ',
                    test: () => {
                        return typeof requestAnimationFrame === 'function';
                    }
                },
                {
                    name: 'ãƒ‡ãƒã‚¤ã‚¹æƒ…å ±å–å¾—',
                    test: () => {
                        const info = {
                            userAgent: navigator.userAgent,
                            platform: navigator.platform,
                            language: navigator.language,
                            cookieEnabled: navigator.cookieEnabled,
                            onLine: navigator.onLine,
                            screenWidth: screen.width,
                            screenHeight: screen.height,
                            devicePixelRatio: window.devicePixelRatio || 1
                        };
                        return info;
                    }
                }
            ];

            totalTests = tests.length;
            currentTestIndex = 0;

            for (const test of tests) {
                try {
                    const result = test.test();
                    const passed = typeof result === 'boolean' ? result : !!result;
                    addTestResult('browser-support', test.name, passed, '', 
                        typeof result === 'object' ? result : null);
                } catch (error) {
                    addTestResult('browser-support', test.name, false, error.message);
                }
                
                currentTestIndex++;
                updateProgress(currentTestIndex, totalTests);
                await new Promise(resolve => setTimeout(resolve, 100));
            }
        }

        // çµ±åˆãƒ†ã‚¹ãƒˆ
        async function runIntegrationTests() {
            const tests = [
                {
                    name: 'ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³åˆæœŸåŒ–',
                    test: async () => {
                        const app = new App();
                        await app.init();
                        return app.appState.isInitialized;
                    }
                },
                {
                    name: 'ç”»é¢é·ç§»ãƒ†ã‚¹ãƒˆ',
                    test: async () => {
                        const app = new App();
                        await app.init();
                        
                        const screens = ['main-menu', 'practice-view', 'example-view', 'result-view'];
                        for (const screen of screens) {
                            app.showScreen(screen);
                            if (app.currentScreen !== screen) {
                                return false;
                            }
                        }
                        return true;
                    }
                },
                {
                    name: 'æç”»ã‚µãƒ¼ãƒ“ã‚¹çµ±åˆ',
                    test: () => {
                        const canvas = document.createElement('canvas');
                        canvas.width = 400;
                        canvas.height = 400;
                        
                        const drawingService = new DrawingService();
                        const result = drawingService.initCanvas(canvas);
                        
                        if (!result) return false;
                        
                        // æç”»ãƒ†ã‚¹ãƒˆ
                        drawingService.startDrawing(100, 100);
                        drawingService.addPoint(150, 150);
                        drawingService.endDrawing();
                        
                        return drawingService.drawingData.strokes.length > 0;
                    }
                },
                {
                    name: 'æ–‡å­—èªè­˜ã‚µãƒ¼ãƒ“ã‚¹çµ±åˆ',
                    test: () => {
                        const recognitionService = new RecognitionService();
                        const mockDrawingData = {
                            strokes: [[
                                { x: 100, y: 100, timestamp: Date.now() },
                                { x: 150, y: 150, timestamp: Date.now() + 100 }
                            ]],
                            timestamp: Date.now(),
                            boundingBox: { x: 100, y: 100, width: 50, height: 50 }
                        };
                        
                        const result = recognitionService.recognizeCharacter(mockDrawingData, 'ã‚');
                        return result && result.character === 'ã‚';
                    }
                },
                {
                    name: 'æ¡ç‚¹ã‚µãƒ¼ãƒ“ã‚¹çµ±åˆ',
                    test: () => {
                        const scoreService = new ScoreService();
                        const mockRecognitionResult = {
                            character: 'ã‚',
                            confidence: 0.8,
                            recognized: true
                        };
                        const mockDrawingData = {
                            strokes: [[{ x: 100, y: 100 }]],
                            boundingBox: { x: 100, y: 100, width: 50, height: 50 }
                        };
                        
                        const result = scoreService.calculateScore(mockRecognitionResult, 'ã‚', mockDrawingData);
                        return result && ['excellent', 'good', 'fair', 'poor'].includes(result.level);
                    }
                },
                {
                    name: 'ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°çµ±åˆ',
                    test: () => {
                        const errorHandler = new ErrorHandler();
                        
                        // ã‚¨ãƒ©ãƒ¼å‡¦ç†ãƒ†ã‚¹ãƒˆ
                        const testError = {
                            type: 'test',
                            message: 'ãƒ†ã‚¹ãƒˆã‚¨ãƒ©ãƒ¼',
                            timestamp: Date.now()
                        };
                        
                        const result = errorHandler.handleError(testError);
                        return result && result.handled;
                    }
                },
                {
                    name: 'å®Œå…¨ãƒ•ãƒ­ãƒ¼çµ±åˆãƒ†ã‚¹ãƒˆ',
                    test: async () => {
                        const app = new App();
                        await app.init();
                        
                        // ç·´ç¿’é–‹å§‹
                        app.startPractice();
                        if (app.currentScreen !== 'practice-view') return false;
                        
                        // æç”»ãƒ‡ãƒ¼ã‚¿ã‚’æ¨¡æ“¬
                        app.drawingService.drawingData = {
                            strokes: [[{ x: 100, y: 100, timestamp: Date.now() }]],
                            timestamp: Date.now(),
                            boundingBox: { x: 100, y: 100, width: 50, height: 50 }
                        };
                        
                        // æç”»æå‡º
                        await app.submitDrawing();
                        
                        return app.currentScreen === 'result-view';
                    }
                }
            ];

            totalTests = tests.length;
            currentTestIndex = 0;

            for (const test of tests) {
                try {
                    const result = await test.test();
                    addTestResult('integration-results', test.name, !!result);
                } catch (error) {
                    addTestResult('integration-results', test.name, false, error.message);
                    addTestResult('error-log', `çµ±åˆãƒ†ã‚¹ãƒˆã‚¨ãƒ©ãƒ¼: ${test.name}`, false, error.stack);
                }
                
                currentTestIndex++;
                updateProgress(currentTestIndex, totalTests);
                await new Promise(resolve => setTimeout(resolve, 200));
            }
        }

        // ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãƒ†ã‚¹ãƒˆ
        async function runPerformanceTests() {
            const tests = [
                {
                    name: 'æç”»ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹',
                    test: () => {
                        const canvas = document.createElement('canvas');
                        canvas.width = 400;
                        canvas.height = 400;
                        
                        const drawingService = new DrawingService();
                        drawingService.initCanvas(canvas);
                        
                        const startTime = performance.now();
                        
                        // å¤§é‡ã®æç”»æ“ä½œ
                        for (let i = 0; i < 100; i++) {
                            drawingService.startDrawing(i, i);
                            for (let j = 0; j < 10; j++) {
                                drawingService.addPoint(i + j, i + j);
                            }
                            drawingService.endDrawing();
                        }
                        
                        const endTime = performance.now();
                        const duration = endTime - startTime;
                        
                        return { passed: duration < 1000, duration: `${duration.toFixed(2)}ms` };
                    }
                },
                {
                    name: 'èªè­˜ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹',
                    test: () => {
                        const recognitionService = new RecognitionService();
                        const mockDrawingData = {
                            strokes: Array.from({ length: 10 }, (_, i) => 
                                Array.from({ length: 20 }, (_, j) => ({
                                    x: i * 10 + j,
                                    y: i * 10 + j,
                                    timestamp: Date.now() + j
                                }))
                            ),
                            timestamp: Date.now(),
                            boundingBox: { x: 0, y: 0, width: 200, height: 200 }
                        };
                        
                        const startTime = performance.now();
                        
                        // è¤‡æ•°å›èªè­˜å®Ÿè¡Œ
                        for (let i = 0; i < 10; i++) {
                            recognitionService.recognizeCharacter(mockDrawingData, 'ã‚');
                        }
                        
                        const endTime = performance.now();
                        const duration = endTime - startTime;
                        
                        return { passed: duration < 500, duration: `${duration.toFixed(2)}ms` };
                    }
                },
                {
                    name: 'ãƒ¡ãƒ¢ãƒªä½¿ç”¨é‡',
                    test: () => {
                        if (!performance.memory) {
                            return { passed: true, message: 'ãƒ¡ãƒ¢ãƒªæƒ…å ±å–å¾—ä¸å¯' };
                        }
                        
                        const initialMemory = performance.memory.usedJSHeapSize;
                        
                        // ãƒ¡ãƒ¢ãƒªã‚’ä½¿ç”¨ã™ã‚‹æ“ä½œ
                        const app = new App();
                        const largeData = Array.from({ length: 10000 }, (_, i) => ({
                            id: i,
                            data: `test data ${i}`.repeat(100)
                        }));
                        
                        const finalMemory = performance.memory.usedJSHeapSize;
                        const memoryIncrease = finalMemory - initialMemory;
                        
                        return { 
                            passed: memoryIncrease < 50 * 1024 * 1024, // 50MBä»¥ä¸‹
                            memory: `${(memoryIncrease / 1024 / 1024).toFixed(2)}MBå¢—åŠ `
                        };
                    }
                }
            ];

            totalTests = tests.length;
            currentTestIndex = 0;

            for (const test of tests) {
                try {
                    const result = test.test();
                    const passed = result.passed !== undefined ? result.passed : !!result;
                    const message = result.duration || result.memory || result.message || '';
                    addTestResult('performance-results', test.name, passed, message);
                } catch (error) {
                    addTestResult('performance-results', test.name, false, error.message);
                    addTestResult('error-log', `ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãƒ†ã‚¹ãƒˆã‚¨ãƒ©ãƒ¼: ${test.name}`, false, error.stack);
                }
                
                currentTestIndex++;
                updateProgress(currentTestIndex, totalTests);
                await new Promise(resolve => setTimeout(resolve, 100));
            }
        }

        // å…¨ãƒ†ã‚¹ãƒˆå®Ÿè¡Œ
        window.runAllTests = async function() {
            // çµæœã‚’ã‚¯ãƒªã‚¢
            ['browser-support', 'integration-results', 'performance-results', 'error-log'].forEach(id => {
                document.getElementById(id).innerHTML = '';
            });
            testResults = [];
            
            document.getElementById('test-status').textContent = 'ãƒ†ã‚¹ãƒˆé–‹å§‹...';
            
            try {
                await runBrowserTests();
                await runIntegrationTests();
                await runPerformanceTests();
                
                const totalPassed = testResults.filter(r => r.passed).length;
                const totalFailed = testResults.filter(r => !r.passed).length;
                
                document.getElementById('test-status').innerHTML = `
                    <strong>ãƒ†ã‚¹ãƒˆå®Œäº†</strong><br>
                    æˆåŠŸ: ${totalPassed}, å¤±æ•—: ${totalFailed}, åˆè¨ˆ: ${testResults.length}
                `;
                
                // çµæœã‚’LocalStorageã«ä¿å­˜
                localStorage.setItem('hiragana_test_results', JSON.stringify({
                    timestamp: new Date().toISOString(),
                    results: testResults,
                    summary: { passed: totalPassed, failed: totalFailed, total: testResults.length }
                }));
                
            } catch (error) {
                document.getElementById('test-status').textContent = `ãƒ†ã‚¹ãƒˆå®Ÿè¡Œã‚¨ãƒ©ãƒ¼: ${error.message}`;
                addTestResult('error-log', 'ãƒ†ã‚¹ãƒˆå®Ÿè¡Œã‚¨ãƒ©ãƒ¼', false, error.stack);
            }
        };

        // å€‹åˆ¥ãƒ†ã‚¹ãƒˆå®Ÿè¡Œé–¢æ•°ã‚’ã‚°ãƒ­ãƒ¼ãƒãƒ«ã«å…¬é–‹
        window.runBrowserTests = runBrowserTests;
        window.runIntegrationTests = runIntegrationTests;
        window.runPerformanceTests = runPerformanceTests;

        // ãƒšãƒ¼ã‚¸èª­ã¿è¾¼ã¿æ™‚ã«ãƒ–ãƒ©ã‚¦ã‚¶æƒ…å ±ã‚’è¡¨ç¤º
        document.addEventListener('DOMContentLoaded', () => {
            const info = document.createElement('div');
            info.className = 'test-info';
            info.innerHTML = `
                <strong>ãƒ–ãƒ©ã‚¦ã‚¶æƒ…å ±</strong><br>
                User Agent: ${navigator.userAgent}<br>
                Platform: ${navigator.platform}<br>
                Language: ${navigator.language}<br>
                Screen: ${screen.width}x${screen.height}<br>
                Device Pixel Ratio: ${window.devicePixelRatio || 1}
            `;
            document.getElementById('browser-support').appendChild(info);
        });
    </script>
</body>
</html>